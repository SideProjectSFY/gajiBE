<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.gaji.corebackend.mapper.ConversationMapper">

    <!-- Result Maps -->
    <resultMap id="ConversationResultMap" type="com.gaji.corebackend.entity.Conversation">
        <id property="id" column="id"/>
        <result property="userId" column="user_id"/>
        <result property="scenarioId" column="scenario_id"/>
        <result property="scenarioType" column="scenario_type"/>
        <result property="characterVectordbId" column="character_vectordb_id"/>
        <result property="parentConversationId" column="parent_conversation_id"/>
        <result property="title" column="title"/>
        <result property="isRoot" column="is_root"/>
        <result property="hasBeenForked" column="has_been_forked"/>
        <result property="messageCount" column="message_count"/>
        <result property="likeCount" column="like_count"/>
        <result property="isPrivate" column="is_private"/>
        <result property="createdAt" column="created_at"/>
        <result property="updatedAt" column="updated_at"/>
        <result property="bookTitle" column="book_title"/>
        <result property="bookAuthor" column="book_author"/>
        <result property="bookCoverUrl" column="book_cover_url"/>
        <result property="bookId" column="book_id"/>
        <result property="scenarioDescription" column="scenario_description"/>
    </resultMap>

    <resultMap id="MessageResultMap" type="com.gaji.corebackend.entity.Message">
        <id property="id" column="id"/>
        <result property="conversationId" column="conversation_id"/>
        <result property="senderId" column="sender_id"/>
        <result property="role" column="role"/>
        <result property="content" column="content"/>
        <result property="createdAt" column="created_at"/>
    </resultMap>

    <!-- Insert Conversation -->
    <insert id="insert" parameterType="com.gaji.corebackend.entity.Conversation">
        INSERT INTO conversations (
            id, user_id, scenario_id, scenario_type, character_vectordb_id,
            parent_conversation_id, title, is_root, has_been_forked, is_private, created_at, updated_at
        ) VALUES (
            #{id}, #{userId}, #{scenarioId}, #{scenarioType}, #{characterVectordbId},
            #{parentConversationId}, #{title}, #{isRoot}, #{hasBeenForked}, #{isPrivate}, NOW(), NOW()
        )
    </insert>

    <!-- Find by ID -->
    <select id="findById" resultMap="ConversationResultMap">
        SELECT * FROM conversations WHERE id = #{id}
    </select>

    <!-- Find by ID with Messages -->
    <select id="findByIdWithMessages" resultMap="ConversationResultMap">
        SELECT * FROM conversations WHERE id = #{id}
    </select>

    <!-- Find by User ID -->
    <select id="findByUserId" resultMap="ConversationResultMap">
        SELECT 
            c.*,
            n.title as book_title,
            n.author as book_author,
            n.cover_image_url as book_cover_url,
            n.id as book_id,
            rus.description as scenario_description
        FROM conversations c
        LEFT JOIN root_user_scenarios rus ON c.scenario_id = rus.id
        LEFT JOIN base_scenarios bs ON rus.base_scenario_id = bs.id
        LEFT JOIN novels n ON bs.novel_id = n.id
        WHERE c.user_id = #{userId}
        ORDER BY c.created_at DESC
        LIMIT #{limit} OFFSET #{offset}
    </select>

    <!-- Find Public by User ID -->
    <!-- Leaf 시나리오 대화 제외: 포크 불가능하므로 공개 목록에서 숨김 -->
    <select id="findPublicByUserId" resultMap="ConversationResultMap">
        SELECT 
            c.*,
            n.title as book_title,
            n.author as book_author,
            n.cover_image_url as book_cover_url,
            n.id as book_id,
            rus.description as scenario_description
        FROM conversations c
        INNER JOIN root_user_scenarios rus ON c.scenario_id = rus.id
        LEFT JOIN base_scenarios bs ON rus.base_scenario_id = bs.id
        LEFT JOIN novels n ON bs.novel_id = n.id
        WHERE c.user_id = #{userId} AND c.is_private = false
        ORDER BY c.created_at DESC
        LIMIT #{limit} OFFSET #{offset}
    </select>

    <!-- Find Liked by User ID -->
    <select id="findLikedByUserId" resultMap="ConversationResultMap">
        SELECT 
            c.*,
            n.title as book_title,
            n.author as book_author,
            n.cover_image_url as book_cover_url,
            n.id as book_id,
            rus.description as scenario_description
        FROM conversations c
        JOIN conversation_likes cl ON c.id = cl.conversation_id
        LEFT JOIN root_user_scenarios rus ON c.scenario_id = rus.id
        LEFT JOIN base_scenarios bs ON rus.base_scenario_id = bs.id
        LEFT JOIN novels n ON bs.novel_id = n.id
        WHERE cl.user_id = #{userId} 
        <if test="!includePrivate">
            AND c.is_private = false
        </if>
        ORDER BY cl.created_at DESC
        LIMIT #{limit} OFFSET #{offset}
    </select>

    <!-- Find All Public -->
    <!-- Leaf 시나리오 대화 제외: 포크 불가능하므로 공개 목록에서 숨김 -->
    <select id="findPublicAll" resultMap="ConversationResultMap">
        SELECT 
            c.*,
            n.title as book_title,
            n.author as book_author,
            n.cover_image_url as book_cover_url,
            n.id as book_id,
            rus.description as scenario_description
        FROM conversations c
        INNER JOIN root_user_scenarios rus ON c.scenario_id = rus.id
        LEFT JOIN base_scenarios bs ON rus.base_scenario_id = bs.id
        LEFT JOIN novels n ON bs.novel_id = n.id
        WHERE c.is_private = false
        ORDER BY c.created_at DESC
        LIMIT #{limit} OFFSET #{offset}
    </select>

    <!-- Find All Public With Filters -->
    <!-- Leaf 시나리오 대화 제외: 포크 불가능하므로 공개 목록에서 숨김 -->
    <select id="findPublicAllWithFilters" resultMap="ConversationResultMap">
        SELECT 
            c.*,
            n.title as book_title,
            n.author as book_author,
            n.cover_image_url as book_cover_url,
            n.id as book_id,
            rus.description as scenario_description
        FROM conversations c
        INNER JOIN root_user_scenarios rus ON c.scenario_id = rus.id
        LEFT JOIN base_scenarios bs ON rus.base_scenario_id = bs.id
        LEFT JOIN novels n ON bs.novel_id = n.id
        WHERE c.is_private = false
        <if test="search != null and search != ''">
            AND (
                LOWER(c.title) LIKE CONCAT('%', LOWER(#{search}), '%')
                OR LOWER(n.title) LIKE CONCAT('%', LOWER(#{search}), '%')
                OR LOWER(n.author) LIKE CONCAT('%', LOWER(#{search}), '%')
            )
        </if>
        <if test="genre != null and genre != '' and genre != 'All Genres'">
            AND n.genre = #{genre}
        </if>
        <choose>
            <when test="sort == 'Popular'">
                ORDER BY c.like_count DESC, c.created_at DESC
            </when>
            <when test="sort == 'Recommended'">
                ORDER BY c.message_count DESC, c.created_at DESC
            </when>
            <otherwise>
                ORDER BY c.created_at DESC
            </otherwise>
        </choose>
        LIMIT #{limit} OFFSET #{offset}
    </select>

    <!-- Find All -->
    <select id="findAll" resultMap="ConversationResultMap">
        SELECT * FROM conversations
        ORDER BY created_at DESC
        LIMIT #{limit} OFFSET #{offset}
    </select>

    <!-- Update Conversation -->
    <update id="update" parameterType="com.gaji.corebackend.entity.Conversation">
        UPDATE conversations
        SET
            title = #{title},
            is_private = #{isPrivate},
            updated_at = NOW()
        WHERE id = #{id}
    </update>

    <!-- Soft Delete (future implementation with deleted_at column) -->
    <delete id="delete">
        DELETE FROM conversations WHERE id = #{id}
    </delete>

    <!-- Find Messages by Conversation ID -->
    <select id="findMessagesByConversationId" resultMap="MessageResultMap">
        SELECT * FROM messages
        WHERE conversation_id = #{conversationId}
        ORDER BY created_at ASC
    </select>

    <!-- Insert Message -->
    <insert id="insertMessage" parameterType="com.gaji.corebackend.entity.Message">
        INSERT INTO messages (
            id, conversation_id, sender_id, role, content, created_at
        ) VALUES (
            #{id}, #{conversationId}, #{senderId}, #{role}, #{content}, 
            <choose>
                <when test="createdAt != null">#{createdAt}</when>
                <otherwise>NOW()</otherwise>
            </choose>
        )
    </insert>

    <!-- Update Message Count -->
    <update id="updateMessageCount">
        UPDATE conversations
        SET message_count = (
            SELECT COUNT(*) FROM messages WHERE conversation_id = #{conversationId}
        ),
        updated_at = NOW()
        WHERE id = #{conversationId}
    </update>

    <!-- Count by User ID -->
    <select id="countByUserId" resultType="int">
        SELECT COUNT(*) FROM conversations WHERE user_id = #{userId}
    </select>

    <!-- Update has_been_forked flag -->
    <update id="updateHasBeenForked">
        UPDATE conversations
        SET
            has_been_forked = #{hasBeenForked},
            updated_at = NOW()
        WHERE id = #{conversationId}
    </update>
    
    <select id="existsById" resultType="boolean">
        SELECT EXISTS(SELECT 1 FROM conversations WHERE id = #{id})
    </select>
    
    <!-- Find First Conversation by Scenario ID (oldest conversation) -->
    <select id="findFirstByScenarioId" resultMap="ConversationResultMap">
        SELECT * FROM conversations 
        WHERE scenario_id = #{scenarioId}
        ORDER BY created_at ASC
        LIMIT 1
    </select>

</mapper>
